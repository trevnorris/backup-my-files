'use strict';

const fs = require('fs');
const path = require('path');
const sep = path.sep;

// TODO(trevnorris): Test performance on blake2

const help_txt =
`Usage:
  backup-my-files [options] SRC DEST

Options:
  -v, --verbose         increase verbosity
  -r, --recursive       recurse into directories
  -c, --checksum        skip based on checksum, not mod-time & size OR if used
                        with --only-scan generate the checksum for each file
  -u, --update          skip files that have a newer mod-time on the receiver
  -p, --perms           preserve permissions
  -x, --xxhash64        use 64 bit xxhash instead of sha1 for checksum
                        (requires setting --checksum)
  -y, --xxhash32        use 32 bit xxhash instead of sha1 for checksum
                        (requires setting --checksum)
  -s, --only-scan       only scan SRC and generate file informaion; DEST
                        is ignored
  -o, --output=FILE     write file data scanned from SRC; --only-scan defaults
                        to stdout; file copy has no output by default
  -n, --input=FILE      location of a JSON file generated by a previous --output
                        that new file copy information is merged into
                        TODO: should this only be for full copy, or should this
                        be allowed  to merge --scan-only output as well?
  -b, --buf-size=NUM    size of buffer in bytes to read in files when
                        generating sha1, default 32MB
  -i, --include-hidden  include hidden files in scan
  -t, --status-bar      display status bar of progress; if used with --only-scan
                        must also set --output
      --in-place        if a file will be written over, don't first move that
                        file to a backup
  -e, --verify=FILE     use JSON FILE to verify files in SRC (TODO: implement)
  -h, --help            Print this help message
`;

const argv = require('minimist')(process.argv.slice(2), {
  boolean: ['v', 'verbose', 'r', 'recursive', 'c', 'checksum', 'u', 'update',
            'p', 'perms', 'x', 'xxhash64', 'y', 'xxhash32', 's', 'only-scan',
            'g', 'gen-hash', 'i', 'include-hidden', 't', 'status-bar', 'h',
            'help']
});

if (process.argv.length <= 2 || argv['help'] || argv.h) {
  fs.writeSync(1, help_txt);
  process.exit();
}

const verbose = !!(argv['verbose'] || argv.v);
const recursive = !!(argv['recursive'] || argv.r);
const checksum = !!(argv['checksum'] || argv.c);
const update = !!(argv['update'] || argv.u);
const perms = !!(argv['perms'] || argv.p);
const xxhash64 = !!(argv['xxhash64'] || argv.x);
const xxhash32 = !!(argv['xxhash32'] || argv.y);
const only_scan = !!(argv['only-scan'] || argv.s);
const include_hidden = !!(argv['include-hidden'] || argv.i);
const status_bar = !!(argv['status-bar'] || argv.t);
const in_place = !!argv['in-place'];

const output = argv['output'] || argv.o || null;
const input = argv['input'] || argv.n || null;
const buf_size = Math.floor(argv['buf-size'] || argv.b) || 0x2000000;

if (!argv._[0]) {
  throw new Error('SRC must be defined');
}
if (!only_scan && !argv._[1]) {
  throw new Error('DEST must be defined if not scanning');
}
if (only_scan && status_bar && !output) {
  throw new Error(
    '--output must be set when using --only-scan and --status-bar');
}

const src_path = path.normalize(argv._[0]);
const src_realpath = fs.realpathSync(src_path);
const dest_path = !only_scan ? path.normalize(argv._[1]) : null;
const dest_realpath = dest_path ? fs.realpathSync(dest_path) : null;

if (src_realpath === dest_realpath && !only_scan)
  throw new Error('SRC and DEST cannot be the same');

{
  const src_stat = fs.lstatSync(src_realpath);
  // TODO(trevnorris): Support symlinks
  if (!src_stat.isDirectory())
    throw new TypeError('SRC must be a directory');
  if (!only_scan) {
    const dest_stat = fs.lstatSync(dest_realpath);
    if (!dest_stat.isDirectory())
      throw new TypeError('DEST must be a directory');
  }
}

// Open fd to output early to make sure we can have access to it.
const output_fd = output === null ? 1 : fs.openSync(output, 'w+');
// TODO(trevnorris): The file copy information shouldn't be merged into this
// until after each file has been successfully copied.
const input_data = input === null ? {} : JSON.parse(fs.readFileSync(input));

// NOTE: hash of length 40 is sha1, 16 is xxhash64 and 8 is xxhash32. Use this
// when reading in a JSON later for verification.

const hashBuf = Buffer.alloc(buf_size);
// TODO(trevnorris): When doing file copy --output should contain the file data
// for each file that's copied, generated after it's copied. Not the metadata
// collected about the files about to be copied. Actually, this file structure
// only really needs to be used for --only-scan
const fs_files = { total_size: 0, total_files: 0, files_list: {} };

/**
 * future options:
 * - follow symlinks
 * - allow running validation of files based on checksum output of previous scan
 */


if (only_scan)
  return onlyScan();


// TODO(trevnorris): Finish implementation.
throw new Error('only directory scanning is currently supported');

fs.writeSync(1,
  `Copying files from ${src_realpath} to ${dest_realpath}\n` +
  'Please make sure no backup files are written to during this time\n');

// First generate object of files
genFilesList(src_realpath, fs_files.files_list);

process.stdout.write(
  `Detected ${fs_files.total_files} files at ${fs_files.total_size} bytes\n`);

const copied_info = input === null ?
  { total_size: 0, total_files: 0, files_list: {} } :
  JSON.parse(fs.readFileSync(input));

// Quick verification that "input" has correct structure.
if (typeof copied_info.total_size !== 'number' ||
    typeof copied_info.total_files !== 'number' ||
    typeof copied_info.files_list !== 'object' ||
    copied_info.files_list === null ||
    Object.keys(copied_info).length !== 3) {
  throw new Error('--input file has incorrect structure');
}

(function copyFiles(files_list, cum_path) {
  for (let entry in files_list) {
    const entry_path = cum_entry + sep + entry;

    // Handle directories.
    if (files_list[entry].type === 'd') {
      // Create directory if it doesn't exist.
      // TODO(trevnorris): Need much better error recovery.
      try {
        const entry_stats = fs.lstatSync(entry_path);
        // Does exist. Update perms if --perms was passed.
        if (perms && entry_stats.mode & 0o777 !== file_list[entry].perms)
          fs.chmodSync(entry_path, file_list[entry].perms);
      } catch (e) {
        if (e.code !== 'ENOENT')
          throw new Error('unexepcted error: ' + e.message);
        // Directory doesn't exist. Create it.
        const new_perms = perms ? files_list[entry].perms : undefined;
        fs.mkdirSync(entry_path, new_perms);
      }
      copyFiles(files_list[entry].list, entry_path);
      continue;
    }

    // Handle files.
    // XXX TODO left off implementing file copy support.
    try {
      const entry_stats = fs.lstatSync(cum_path + sep + entry);
      if (!checksum && !update) {
      }
      // Copy files based on difference in checksum.
      if (checksum) {
        continue;
      }
      if (update) {
        continue;
      }
    } catch (e) {
      if (e.code !== 'ENOENT')
        throw new Error('unexpected error: ' + e.message);
    }
  }
})(fs_files.files_list, dest_realpath);


function copyFile(cum_path) {
  const src_fd = fs.openSync(src_realpath + sep + cum_path, 'r');
  const dest_fd = fs.openSync(dest_realpath + sep + cum_path, 'w');
  let bytesRead = 0;
  let cumRead = 0;
  do {
    bytesRead = fs.readSync(src_fd, hashBuf, 0, hashBuf.byteLength, cumRead);
    fs.writeSync(dest_fd, hashBuf.slice(0, bytesRead), 0, bytesRead, cumRead);
    cumRead += bytesRead;
  } while (bytesRead >= hashBuf.byteLength);
}
